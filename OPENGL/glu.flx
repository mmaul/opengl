//Module        : GL_glu_h
//Timestamp     : 2006/1/23 15:46:10 UTC
//Timestamp     : 2006/1/24 2:46:10 (local)
//Raw Header    : /usr/include/GL/glu.h
//Preprocessor  : gcc -E
//Input file: gl.flxcc.i
//Flxcc Control : gl.flxcc
//Felix Version : 1.1.2_rc1

//INCLUDES
include "OPENGL/gl";

class GLU
{
  requires package "opengl-glu";
  open C_hack;
  open GL;

  const GLU_TESS_MAX_COORD : int;
  const GLU_TESS_WINDING_ABS_GEQ_TWO : int;
  const GLU_TESS_WINDING_NEGATIVE : int;
  const GLU_TESS_WINDING_POSITIVE : int;
  const GLU_TESS_WINDING_NONZERO : int;
  const GLU_TESS_WINDING_ODD : int;
  const GLU_TESS_NEED_COMBINE_CALLBACK : int;
  const GLU_TESS_COORD_TOO_LARGE : int;
  const GLU_TESS_MISSING_END_CONTOUR : int;
  const GLU_TESS_MISSING_END_POLYGON : int;
  const GLU_TESS_MISSING_BEGIN_CONTOUR : int;
  const GLU_TESS_MISSING_BEGIN_POLYGON : int;
  const GLU_TESS_ERROR8 : int;
  const GLU_TESS_ERROR7 : int;
  const GLU_TESS_ERROR6 : int;
  const GLU_TESS_ERROR5 : int;
  const GLU_TESS_ERROR4 : int;
  const GLU_TESS_ERROR3 : int;
  const GLU_TESS_ERROR2 : int;
  const GLU_TESS_ERROR1 : int;
  const GLU_TESS_TOLERANCE : int;
  const GLU_TESS_BOUNDARY_ONLY : int;
  const GLU_TESS_WINDING_RULE : int;
  const GLU_UNKNOWN : int;
  const GLU_EXTERIOR : int;
  const GLU_INTERIOR : int;
  const GLU_CCW : int;
  const GLU_CW : int;
  const GLU_TESS_COMBINE_DATA : int;
  const GLU_TESS_EDGE_FLAG_DATA : int;
  const GLU_TESS_ERROR_DATA : int;
  const GLU_TESS_END_DATA : int;
  const GLU_TESS_VERTEX_DATA : int;
  const GLU_TESS_BEGIN_DATA : int;
  const GLU_TESS_COMBINE : int;
  const GLU_EDGE_FLAG : int;
  const GLU_TESS_EDGE_FLAG : int;
  const GLU_TESS_ERROR : int;
  const GLU_END : int;
  const GLU_TESS_END : int;
  const GLU_VERTEX : int;
  const GLU_TESS_VERTEX : int;
  const GLU_BEGIN : int;
  const GLU_TESS_BEGIN : int;
  const GLU_INSIDE : int;
  const GLU_OUTSIDE : int;
  const GLU_NONE : int;
  const GLU_FLAT : int;
  const GLU_SMOOTH : int;
  const GLU_SILHOUETTE : int;
  const GLU_FILL : int;
  const GLU_LINE : int;
  const GLU_POINT : int;
  const GLU_MAP1_TRIM_3 : int;
  const GLU_MAP1_TRIM_2 : int;
  const GLU_DOMAIN_DISTANCE : int;
  const GLU_PARAMETRIC_ERROR : int;
  const GLU_PATH_LENGTH : int;
  const GLU_OBJECT_PATH_LENGTH_EXT : int;
  const GLU_OBJECT_PATH_LENGTH : int;
  const GLU_OBJECT_PARAMETRIC_ERROR_EXT : int;
  const GLU_OBJECT_PARAMETRIC_ERROR : int;
  const GLU_NURBS_RENDERER_EXT : int;
  const GLU_NURBS_RENDERER : int;
  const GLU_NURBS_TESSELLATOR_EXT : int;
  const GLU_NURBS_TESSELLATOR : int;
  const GLU_NURBS_MODE_EXT : int;
  const GLU_NURBS_MODE : int;
  const GLU_V_STEP : int;
  const GLU_U_STEP : int;
  const GLU_SAMPLING_METHOD : int;
  const GLU_PARAMETRIC_TOLERANCE : int;
  const GLU_DISPLAY_MODE : int;
  const GLU_SAMPLING_TOLERANCE : int;
  const GLU_CULLING : int;
  const GLU_AUTO_LOAD_MATRIX : int;
  const GLU_NURBS_ERROR37 : int;
  const GLU_NURBS_ERROR36 : int;
  const GLU_NURBS_ERROR35 : int;
  const GLU_NURBS_ERROR34 : int;
  const GLU_NURBS_ERROR33 : int;
  const GLU_NURBS_ERROR32 : int;
  const GLU_NURBS_ERROR31 : int;
  const GLU_NURBS_ERROR30 : int;
  const GLU_NURBS_ERROR29 : int;
  const GLU_NURBS_ERROR28 : int;
  const GLU_NURBS_ERROR27 : int;
  const GLU_NURBS_ERROR26 : int;
  const GLU_NURBS_ERROR25 : int;
  const GLU_NURBS_ERROR24 : int;
  const GLU_NURBS_ERROR23 : int;
  const GLU_NURBS_ERROR22 : int;
  const GLU_NURBS_ERROR21 : int;
  const GLU_NURBS_ERROR20 : int;
  const GLU_NURBS_ERROR19 : int;
  const GLU_NURBS_ERROR18 : int;
  const GLU_NURBS_ERROR17 : int;
  const GLU_NURBS_ERROR16 : int;
  const GLU_NURBS_ERROR15 : int;
  const GLU_NURBS_ERROR14 : int;
  const GLU_NURBS_ERROR13 : int;
  const GLU_NURBS_ERROR12 : int;
  const GLU_NURBS_ERROR11 : int;
  const GLU_NURBS_ERROR10 : int;
  const GLU_NURBS_ERROR9 : int;
  const GLU_NURBS_ERROR8 : int;
  const GLU_NURBS_ERROR7 : int;
  const GLU_NURBS_ERROR6 : int;
  const GLU_NURBS_ERROR5 : int;
  const GLU_NURBS_ERROR4 : int;
  const GLU_NURBS_ERROR3 : int;
  const GLU_NURBS_ERROR2 : int;
  const GLU_NURBS_ERROR1 : int;
  const GLU_NURBS_END_DATA_EXT : int;
  const GLU_NURBS_END_DATA : int;
  const GLU_NURBS_TEX_COORD_DATA_EXT : int;
  const GLU_NURBS_TEXTURE_COORD_DATA : int;
  const GLU_NURBS_COLOR_DATA_EXT : int;
  const GLU_NURBS_COLOR_DATA : int;
  const GLU_NURBS_NORMAL_DATA_EXT : int;
  const GLU_NURBS_NORMAL_DATA : int;
  const GLU_NURBS_VERTEX_DATA_EXT : int;
  const GLU_NURBS_VERTEX_DATA : int;
  const GLU_NURBS_BEGIN_DATA_EXT : int;
  const GLU_NURBS_BEGIN_DATA : int;
  const GLU_NURBS_END_EXT : int;
  const GLU_NURBS_END : int;
  const GLU_NURBS_TEX_COORD_EXT : int;
  const GLU_NURBS_TEXTURE_COORD : int;
  const GLU_NURBS_COLOR_EXT : int;
  const GLU_NURBS_COLOR : int;
  const GLU_NURBS_NORMAL_EXT : int;
  const GLU_NURBS_NORMAL : int;
  const GLU_NURBS_VERTEX_EXT : int;
  const GLU_NURBS_VERTEX : int;
  const GLU_NURBS_BEGIN_EXT : int;
  const GLU_NURBS_BEGIN : int;
  const GLU_ERROR : int;
  const GLU_NURBS_ERROR : int;
  const GLU_OUTLINE_PATCH : int;
  const GLU_OUTLINE_POLYGON : int;
  const GLU_INVALID_OPERATION : int;
  const GLU_INCOMPATIBLE_GL_VERSION : int;
  const GLU_OUT_OF_MEMORY : int;
  const GLU_INVALID_VALUE : int;
  const GLU_INVALID_ENUM : int;
  const GLU_EXTENSIONS : int;
  const GLU_VERSION : int;
  const GLU_VERSION_1_3 : int;
  const GLU_VERSION_1_2 : int;
  const GLU_VERSION_1_1 : int;
  const GLU_TRUE : int;
  const GLU_FALSE : int;
  const GLU_EXT_nurbs_tessellator : int;
  const GLU_EXT_object_space_tess : int;
//#define GLAPI
//#define GLAPIENTRYP GLAPIENTRY *
//#define GLAPIENTRY
//#define __glu_h__

  //C FUNCTION POINTER TYPES
  header '''typedef void (*GL_glu_h_cft_1)();''';
  type GL_glu_h_cft_1 = 'GL_glu_h_cft_1';

  //PURE INCOMPLETE TYPES
  type _struct_GLUnurbs = 'struct GLUnurbs'; //local
  type _struct_GLUquadric = 'struct GLUquadric'; //local
  type _struct_GLUtesselator = 'struct GLUtesselator'; //local

  //STRUCT or UNION TAG ALIASES
  typedef GLUtesselator = _struct_GLUtesselator;
  typedef GLUquadric = _struct_GLUquadric;
  typedef GLUnurbs = _struct_GLUnurbs;

  //TYPE ALIASES
  typedef _GLUfuncptr = GL_glu_h_cft_1;
  typedef GLUtesselatorObj = GLUtesselator;
  typedef GLUnurbsObj = GLUnurbs;
  typedef GLUquadricObj = GLUquadric;
  typedef GLUtriangulatorObj = GLUtesselator;

  //PROCEDURES
  proc gluBeginCurve: &GLUnurbs;
  proc gluBeginPolygon: &GLUtesselator;
  proc gluBeginSurface: &GLUnurbs;
  proc gluBeginTrim: &GLUnurbs;
  proc gluCylinder: &GLUquadric * GLdouble * GLdouble * GLdouble * GLint * GLint;
  proc gluDeleteNurbsRenderer: &GLUnurbs;
  proc gluDeleteQuadric: &GLUquadric;
  proc gluDeleteTess: &GLUtesselator;
  proc gluDisk: &GLUquadric * GLdouble * GLdouble * GLint * GLint;
  proc gluEndCurve: &GLUnurbs;
  proc gluEndPolygon: &GLUtesselator;
  proc gluEndSurface: &GLUnurbs;
  proc gluEndTrim: &GLUnurbs;
  proc gluGetNurbsProperty: &GLUnurbs * GLenum * &GLfloat;
  proc gluGetTessProperty: &GLUtesselator * GLenum * &GLdouble;
  proc gluLoadSamplingMatrices: &GLUnurbs * &GLfloat * &GLfloat * &GLint;
  proc gluLookAt: GLdouble * GLdouble * GLdouble * GLdouble * GLdouble * GLdouble * GLdouble * GLdouble * GLdouble;
  proc gluNextContour: &GLUtesselator * GLenum;
  proc gluNurbsCallback: &GLUnurbs * GLenum * GL_glu_h_cft_1;
  proc gluNurbsCallbackData: &GLUnurbs * &GLvoid;
  proc gluNurbsCallbackDataEXT: &GLUnurbs * &GLvoid;
  proc gluNurbsCurve: &GLUnurbs * GLint * &GLfloat * GLint * &GLfloat * GLint * GLenum;
  proc gluNurbsProperty: &GLUnurbs * GLenum * GLfloat;
  proc gluNurbsSurface: &GLUnurbs * GLint * &GLfloat * GLint * &GLfloat * GLint * GLint * &GLfloat * GLint * GLint * GLenum;
  proc gluOrtho2D: GLdouble * GLdouble * GLdouble * GLdouble;
  proc gluPartialDisk: &GLUquadric * GLdouble * GLdouble * GLint * GLint * GLdouble * GLdouble;
  proc gluPerspective: GLdouble * GLdouble * GLdouble * GLdouble;
  proc gluPickMatrix: GLdouble * GLdouble * GLdouble * GLdouble * &GLint;
  proc gluPwlCurve: &GLUnurbs * GLint * &GLfloat * GLint * GLenum;
  proc gluQuadricCallback: &GLUquadric * GLenum * GL_glu_h_cft_1;
  proc gluQuadricDrawStyle: &GLUquadric * GLenum;
  proc gluQuadricNormals: &GLUquadric * GLenum;
  proc gluQuadricOrientation: &GLUquadric * GLenum;
  proc gluQuadricTexture: &GLUquadric * GLboolean;
  proc gluSphere: &GLUquadric * GLdouble * GLint * GLint;
  proc gluTessBeginContour: &GLUtesselator;
  proc gluTessBeginPolygon: &GLUtesselator * &GLvoid;
  proc gluTessCallback: &GLUtesselator * GLenum * GL_glu_h_cft_1;
  proc gluTessEndContour: &GLUtesselator;
  proc gluTessEndPolygon: &GLUtesselator;
  proc gluTessNormal: &GLUtesselator * GLdouble * GLdouble * GLdouble;
  proc gluTessProperty: &GLUtesselator * GLenum * GLdouble;
  proc gluTessVertex: &GLUtesselator * &GLdouble * &GLvoid;

  //FUNCTIONS
  fun gluBuild1DMipmapLevels: GLenum * GLint * GLsizei * GLenum * GLenum * GLint * GLint * GLint * address -> GLint;
  fun gluBuild1DMipmaps: GLenum * GLint * GLsizei * GLenum * GLenum * address -> GLint;
  fun gluBuild2DMipmapLevels: GLenum * GLint * GLsizei * GLsizei * GLenum * GLenum * GLint * GLint * GLint * address -> GLint;
  fun gluBuild2DMipmaps: GLenum * GLint * GLsizei * GLsizei * GLenum * GLenum * address -> GLint;
  fun gluBuild3DMipmapLevels: GLenum * GLint * GLsizei * GLsizei * GLsizei * GLenum * GLenum * GLint * GLint * GLint * address -> GLint;
  fun gluBuild3DMipmaps: GLenum * GLint * GLsizei * GLsizei * GLsizei * GLenum * GLenum * address -> GLint;
  fun gluCheckExtension: &GLubyte * &GLubyte -> GLboolean;
  fun gluErrorString: GLenum -> &GLubyte;
  fun gluGetString: GLenum -> &GLubyte;
  fun gluNewNurbsRenderer: 1 -> &GLUnurbs;
  fun gluNewQuadric: 1 -> &GLUquadric;
  fun gluNewTess: 1 -> &GLUtesselator;
  fun gluProject: GLdouble * GLdouble * GLdouble * &GLdouble * &GLdouble * &GLint * &GLdouble * &GLdouble * &GLdouble -> GLint;
  fun gluScaleImage: GLenum * GLsizei * GLsizei * GLenum * address * GLsizei * GLsizei * GLenum * &GLvoid -> GLint;
  fun gluUnProject: GLdouble * GLdouble * GLdouble * &GLdouble * &GLdouble * &GLint * &GLdouble * &GLdouble * &GLdouble -> GLint;
  fun gluUnProject4: GLdouble * GLdouble * GLdouble * GLdouble * &GLdouble * &GLdouble * &GLint * GLdouble * GLdouble * &GLdouble * &GLdouble * &GLdouble * &GLdouble -> GLint;
}
